---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.10.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import random
import math
```

```{python}
operators = '+-*/'
values = '0123456789'
functions = {'sigma':1}
```

```{python}
def sigma(num):
    return sum([i for i in range(1, num) if num % i == 0])
```

```{python}
sigma(6)
```

```{python}
def isOperator(val):
    return val in operators

def isFunction(val):
    return val in functions
```

```{python}
isFunction('sigma')
```

```{python}
isFunction('5')
```

```{python}
def getNode():
    a = math.floor(random.random() * 2)
    b = math.floor(random.random() * 2)
    if a:
        if b:
            return operators[math.floor(random.random() * len(operators))]
        else: 
            return list(functions.keys())[math.floor(random.random() * len(functions))]
    else:
        return values[math.floor(random.random() * len(values))]
```

```{python}
def tree():
    result = []
    
    node = getNode()
    result.append(node)
    
    if isOperator(node):
        left = tree()
        right = tree()
        
        result.extend(left)
        result.extend(right)
        
    elif isFunction(node):
        num_arg = functions[node]
        arg = [tree() for _ in range(num_arg)]
        
#         for i in range(num_arg):
#             vars()[f'arg_{i}'] = tree()
        result.extend(*arg)
        
    return result
```

```{python}
tree()
```

```{python}
# Python Program to convert prefix to Infix
def prefixToInfix(prefix):
    stack = []
     
    # read prefix in reverse order
    i = len(prefix) - 1
    while i >= 0:
        if  isOperator(prefix[i]):
            # symbol is operator
            str = "(" + stack.pop() + prefix[i] + stack.pop() + ")"
            stack.append(str)
            i -= 1
        elif isFunction(prefix[i]):
            # symbol is function
            num_arg = functions[prefix[i]]
            arg = [stack.pop() for i in range(num_arg)]
            str = prefix[i] + "(" + ','.join(arg) +  ")"
            stack.append(str)
            i -= 1
        else:
            # symbol is operand
            stack.append(prefix[i])
            i -= 1
            
     
    return stack.pop()

```

```{python}
a = ['-', '9', '/', '8', 'sigma', 'sigma', '2']
```

```{python}
b = ['sigma',
 'sigma',
 '*',
 '*',
 'sigma',
 '+',
 '4',
 '0',
 '/',
 '*',
 '8',
 'sigma',
 '8',
 '9',
 '*',
 'sigma',
 '1',
 'sigma',
 '7']
```

```{python}
prefixToInfix(b)
```

```{python}
for _ in range(20):
    t = tree()
    print(prefixToInfix(t))
```

```{python}
for _ in range(20):
    t = tree()
    
    try:
        print(eval(prefixToInfix(t)))
    except ZeroDivisionError:
        print('Infi')
    except MemoryError:
        print('Loss memory')
    except TypeError:
        print('float cannot in to sigma')
```

```{python}
def is_operand(c):
    return c in values
 

def evaluate(expression):
    stack = []
 
    # iterate over the string in reverse order
    for c in expression[::-1]:
        # push operand to stack
        if is_operand(c):
            stack.append(eval(c))
        else:
            # pop values from stack can calculate the result
            # push the result onto the stack again
            o1 = stack.pop()
            o2 = stack.pop()
 
            if c == '+':
                stack.append(o1 + o2)
 
            elif c == '-':
                stack.append(o1 - o2)
 
            elif c == '*':
                stack.append(o1 * o2)
 
            elif c == '/':
                stack.append(o1 / o2)
 
    return stack.pop()
```

```{python}
vars()['A'] = 0
```

```{python}
A
```

```{python}
functions = {'sigma':1}
```

```{python}
functions['sigma']
```

```{python}
'sigma' in functions
```

```{python}
list(functions.keys())
```

```{python}
for i in range(1):
    print(i)
```

```{python}
def p():
    print('A')
    return 1
```

```{python}
[p() for i in range(10)]
```

```{python}
k = [1,2,3,4,5]
[k.pop() for i in range(1)]
```

```{python}
sigma(10,)
```

```{python}
','.join(['1','2'])
```

```{python}

```
