---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.10.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import random
import math
```

```{python}
operators = '+-*/'
values = '0123456789'
functions = {'sigma':1, 'delta':2, '+':2, '-':2, '*':2, '/':2}
```

```{python}
def sigma(num):
    return sum([i for i in range(1, num) if num % i == 0])
```

```{python}
def delta(n,m):
    return n**m
```

```{python}
sigma(6)
```

```{python}
delta(10,2)
```

```{python}
delta.__str__().split()[1]
```

```{python}
def isOperator(val):
    return val in operators

def isFunction(val):
    return val in functions
```

```{python}
isFunction('sigma')
```

```{python}
isFunction('5')
```

```{python}
def getNode():
    a = math.floor(random.random() * 2)
    b = math.floor(random.random() * 2)
    if a:
        if b:
            return operators[math.floor(random.random() * len(operators))]
        else: 
            return list(functions.keys())[math.floor(random.random() * len(functions))]
    else:
        return values[math.floor(random.random() * len(values))]
```

```{python}
def tree():
    result = []
    
    node = getNode()
    result.append(node)
    
    if isOperator(node):
        left = tree()
        right = tree()
        
        result.extend(left)
        result.extend(right)
        
    elif isFunction(node):
        num_arg = functions[node]
        arg = [tree() for _ in range(num_arg)]
        
#         for i in range(num_arg):
#             vars()[f'arg_{i}'] = tree()
        for a in arg:
            result.extend(a)
        
    return result
```

```{python}
while True:
    t = tree()
    if len(t)>5:
        print(t)
        break
```

```{python}
# Python Program to convert prefix to Infix
def prefixToInfix(prefix):
    stack = []
     
    # read prefix in reverse order
    i = len(prefix) - 1
    while i >= 0:
        if  isOperator(prefix[i]):
            # symbol is operator
            str = "(" + stack.pop() + prefix[i] + stack.pop() + ")"
            stack.append(str)
            i -= 1
        elif isFunction(prefix[i]):
            # symbol is function
            num_arg = functions[prefix[i]]
            arg = [stack.pop() for i in range(num_arg)]
            str = prefix[i] + "(" + ','.join(arg) +  ")"
            stack.append(str)
            i -= 1
        else:
            # symbol is operand
            stack.append(prefix[i])
            i -= 1
            
     
    return stack.pop()

```

```{python}
a = ['-', '9', '/', '8', 'sigma', 'sigma', '2']
```

```{python}
b = ['/', '3', '*', 'delta', '+', 'sigma', '+', '5', 'delta', '*', '3', 'delta', '-', '-', '9', 'delta', '-', '6', '7', '3', '5', '-', '+', 'delta', 'delta', '3', '-', '4', '5', '1', '4', '7', 'delta', '1', '5', '-', '4', '4', '*', '9', 'delta', '1', 'delta', '8', 'delta', 'delta', '6', '+', '2', 'delta', '/', 'sigma', 'delta', '1', '3', '8', '5', 'delta', '5', 'sigma', '2', 'delta', '4', 'delta', '4', '5']
```

```{python}
prefixToInfix(b)
```

```{python}
for _ in range(20):
    t = tree()
    print(prefixToInfix(t))
```

```{python}
for _ in range(20):
    t = tree()
    
    try:
        print(eval(prefixToInfix(t)))
    except ZeroDivisionError:
        print('Infi')
    except MemoryError:
        print('Loss memory')
    except TypeError:
        print('float cannot in to sigma')
```

```{python}
vars()['A'] = 0
```

```{python}
A
```

```{python}
def a(b,c,d):
    pass
```

```{python}
from inspect import getfullargspec
len(getfullargspec(a)[0])
```

```{python}
a.__str__().split()[1]
```

```{python}
def get_number_of_args(func):
    return len(func.__code__.co_varnames)
```

```{python}
def g(a, b): pass
print (get_number_of_args(g))   # 2
```

```{python}
parts = ['-', '+', '*','sigma','5','6','2','*','3','sigma','2'][10:]
prefixToInfix(parts)
```

```{python}
def subPrefix(prefix,index):
    stack = []
    prefix = prefix[index:]
    # read prefix in reverse order
    i = len(prefix) - 1
    while i >= 0:
        if  isOperator(prefix[i]):
            # symbol is operator
            str = prefix[i] + ','+ stack.pop() + ','+ stack.pop()
            stack.append(str)
            i -= 1
        elif isFunction(prefix[i]):
            # symbol is function
            num_arg = functions[prefix[i]]
            arg = [stack.pop() for i in range(num_arg)]
            str = prefix[i]  + ',' + ','.join(arg)
            stack.append(str)
            i -= 1
        else:
            # symbol is operand
            stack.append(prefix[i])
            i -= 1
            
     
    return stack.pop().split(',')
```

```{python}
parts = ['-', '+', '*','sigma','5','6','2','*','3','sigma','2']
subPrefix(parts,1)
```

```{python}
parts[0:]
```

```{python}
parts[:0]
```

```{python}
def replaceAtIndex(inp, index, search, replace):
    return inp[:index] + replace + inp[index + len(search):]
```

```{python}
def crossOver(parent1, parent2):

 
    index1 = math.floor(random.random() * len(parent1))
    index2 = math.floor(random.random() * len(parent2))

    subtree1 = subPrefix(parent1, index1)
    subtree2 = subPrefix(parent2, index2)

    child1 = replaceAtIndex(parent1, index1, subtree1, subtree2);
    child2 = replaceAtIndex(parent2, index2, subtree2, subtree1);
    
    return [child1, child2]
```

```{python}
a = ['-', '9', '/', '8', 'sigma', 'sigma', '2']
```

```{python}
b = ['/', '3', '*', 'delta', '+', 'sigma', '+', '5', 'delta', '*', '3', 'delta', '-', '-', '9', 'delta', '-', '6', '7', '3', '5', '-', '+', 'delta', 'delta', '3', '-', '4', '5', '1', '4', '7', 'delta', '1', '5', '-', '4', '4', '*', '9', 'delta', '1', 'delta', '8', 'delta', 'delta', '6', '+', '2', 'delta', '/', 'sigma', 'delta', '1', '3', '8', '5', 'delta', '5', 'sigma', '2', 'delta', '4', 'delta', '4', '5']
```

```{python}
g = crossOver(a,b)
```

```{python}
print(g[0])
```

```{python}
print(g[1])
```

```{python}

```
